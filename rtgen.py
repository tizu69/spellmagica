import registry
from utils import pascal, camel
import sys
import lua
import hextypes

reg = registry.get()
production = len(sys.argv) > 1
out = ""
runtimeDocs = not production

if not production:
    out = "--- Code generated by spellmagica. DO NOT EDIT.\n\n"
    out += "--- @class Spellmagica\n"
    out += "--- The Spellmagica runtime v0.0.1\n"
else:
    out = "--[[Code generated by spellmagica. DO NOT EDIT.]]"
out += "local Spellmagica={}"
out += "local pwse='No per-world signature for '"

if runtimeDocs:
    out += "Spellmagica.docs={}"

if not production:
    out += "\n--- Creates a new Spell builder.\n"
    out += "--- @param pw table<string,string>? Per-world signatures\n"
    out += "--- @return Spellmagica\n"
out += "function Spellmagica.new(pw)"
out += "return setmetatable({hex={},pw=pw},{__index=Spellmagica})"
out += "end "

if not production:
    out += "\n--- Pushes a pattern onto the stack.\n"
    out += "--- @param p string\n"
out += "function Spellmagica:p(p)"
out += "table.insert(self.hex, self.pattern(p))"
out += "return self "
out += "end "

if not production:
    out += "\n--- Returns a pattern.\n"
    out += "--- @param p string\n"
    out += "--- @return {startDir:string,angles:string}\n"
out += "function Spellmagica.pattern(p)"
out += 'return {startDir="EAST",angles=p}'
out += "end "

if not production:
    out += "\n--- Pushes a value onto the stack.\n"
    out += "--- @param v "
    for t in hextypes.hexTypes.keys():
        mapped = hextypes.hexTypes[t]
        if mapped != "userdata":
            out += f"{t if hextypes.native(mapped) else mapped}|"
    out = out[:-1] + "\n"  # Remove trailing |
out += "function Spellmagica:push(v)"
out += "self:openParen()"
out += "table.insert(self.hex, v)"
out += "self:closeParen()"
out += "self:splat()"
out += "return self "
out += "end "

pattern_names: dict[str, str] = {}
pattern_uname_ids: dict[str, str] = {}
for pattern in reg["patterns"].values():
    id = pattern["id"]
    mod, name = id.split(":")
    if mod == "hexcasting":
        pattern_names[id] = f"{camel(name.replace('/', '_'))}"
    else:
        pattern_names[id] = f"{camel(mod)}{pascal(name.replace('/', '_'))}"
    if pattern_names[id] in lua.keywords or pattern_names[id][0].isdigit():
        pattern_names[id] = "_" + pattern_names[id]
    pattern_uname_ids[pattern["name"]] = id
if len(sys.argv) > 1:
    with open(sys.argv[1], "r", encoding="utf-8") as f:
        data = f.read()
    patterns_to_build = {pid for pid in pattern_names.values() if pid in data}
else:
    patterns_to_build = set(pattern_names.values())

for pattern in reg["patterns"].values():
    name = pattern_names[pattern["id"]]
    if len(pattern["operators"]) == 0 or name not in patterns_to_build:
        continue

    if not production:
        out += f"\n--- {pattern['name']}\n"
        out += "---\n"
        for op in pattern["operators"]:
            desc = op["description"].replace("\n", "\n--- ")
            signature = f"{op['inputs']} -> {op['outputs']}"
            out += f"--- [[{op['mod_id']}: {signature}]]({op['book_url']}) {desc}<br/>\n"

    out += f"function Spellmagica:{name}(...)"
    if not pattern["is_per_world"]:
        out += f'return self:p"{pattern["signature"]}"'
    else:
        out += f'return self:p(self.pw["{name}"] or error(pwse.."{name}"))'
    out += "end "

    if runtimeDocs:
        out += f'Spellmagica.docs["{name}"]={{'
        out += f'name={lua.str(pattern["name"])},'
        out += f'id="{pattern["id"]}",'
        out += f'signature="{pattern["signature"]}",'
        if pattern["is_per_world"]:
            out += "perworld=true,"
        out += "operators={"
        for op in pattern["operators"]:
            desc = op["description"].replace("\n", " ")
            signature = f"{op['inputs']} -> {op['outputs']}"
            out += f'{{modid="{op["mod_id"]}",'
            out += f'signature="{signature}",'
            out += f"description={lua.str(desc)}}},"
        out += "}}"

out += "return Spellmagica"
print(out)
